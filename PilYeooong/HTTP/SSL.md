## ✔️ SSL

> **SSL**은 _**Secure Socket Layer**_이라는 약자로 보안 소켓 레이어이다.
Netscape에서 **서버와 브라우저 간 보안을 위해 만든 프로토콜**이다.

### 역할
- HTTP 요청과 응답 데이터의 암호화가 이루어진다.
- 클라이언트가 접속한 서버가 신뢰 할 수 있는 서버임을 보장한다.

### 사용 시 이점
- 통신 내용이 공격자에게 노출되지 않는다.
- 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지를 판단할 수 있다.
- 통신 내용의 악의적 변경을 방지 할 수 있다.

## ✔️ SSL 인증서

> **SSL** 인증서는 클라이언트와 서버 간의 통신을 제 3자가 보증해주는 전자화 된 문서


### CA (Certificate Authority)

>`SSL 인증서는 제 3자가 보증해주는 문서`이다. 여기에 해당 되는 제 3자들이 바로 `Certificate Authority`다.
- 디지털 인증서를 제공하는 공인된 기업들 (`Certificate Authority` 혹은  `Root Certificate`라 부름)
- 당연하게도 아무 기업이나 할 수 있는 것은 아니고, **신뢰성이 엄격하게 공인 된 기업**들 만이 참여가 가능하다.

<br />

## ✔️ SSL의 암호화

**SSL**은 보안과 성능 상의 이유로 두가지 암호화 기법을 혼용해서 사용하고 있는데, 우선 이 두가지 암호화 기법에 대해서 정리해보았다.

### 👉🏻 대칭키

- 암호화와 복호화에 사용되는 키가 같다

- 만약에, 정보 송 수신이 이루어 진다면, 정보 전송시에 암호화 키도 같이 전송하여야한다.

- 이 과정에서, 키가 유출되면, 암호화 된 내용을 공격자가 복호화 할 수 있기 때문에 위험하다

- 이를 보완하기 위해 나온 방법이 `공개키 암호화 방식`이다.

### 👉🏻 공개키

- 암호화와 복호화에 서로 다른 키를 사용한다.

- 두개의 키를 가지고 있다 (A키, B키)

- A키로 암호화하면 B키로 복호화가 가능하고, B키로 암호화하면 A키로 복호화를 할 수 있도록 하는 방식

- 이 방식에 착안해서 두개의 키 중 하나를 비밀키(private key)로 지정, 나머지를 공개키(public key)로 지정한다.

- 비밀키는 오직 호스트(서버)만이 가지고 있으며, 클라이언트는 공개키를 사용해 메시지를 암호화 하여 전송 한다.

- 암호화 된 정보는 오직 비밀키를 가지고 있는 호스트(서버)만이 복호화 할 수 있다.

> **여기서 의문점** 🤔
>
> 반대로 호스트(서버)가 정보를 암호화해서 클라이언트에게 보내는 경우는 없을까 ?
이 경우에 호스트(서버)가 데이터를  비밀키를 통해 암호화해서 클라이언트에게 보낸다면, 이 과정에서 악의적인 공격으로, _**"노출 된 공개키를 통해 서버에서 보낸 정보를 복호화 할 수 있지 않을까?"**_ 라는 부분이다.
그럼에도 굳이 암호화를 해서 보내는 이유는 뭘까? 이러한 방식은 `디지털 서명` 에 이용된다.

<br />

## ✔️ 디지털 서명

디지털 서명을 통해, 누가 메시지를 썼는지, 메시지의 위조, 변조 여부에 대한 증명이 가능하다. SSL 인증서에서 서비스를 보증하는 방법으로 활용 된다.

- 비밀키를 갖고 있는 호스트가 데이터를 암호화 한 후, 공개키와 함께 암호화 된 데이터를 전송한다.
→ '혹여나 중간에 유출되지는 않을까 ?' 할 수 있지만, 이는 데이터를 보호하기 위한 목적이 아니다.

- 클라이언트는 암호화 된 데이터를 공개키를 통해 복호화 할 수 있다.

- 이는 데이터가 공개키와 쌍을 이루는 비밀키에 의해 암호화 되었다는 것을 의미 한다.

- 공개키를 통해 데이터의 출처, 데이터를 제공한 사람의 신원이 보장 된다.

<br />

## ✔️ SSL 동작

- 공개키 방식과, 대칭키 방식을 혼합하여 사용한다.
- 공개키 방식은 알고리즘 계산이 느리고, 컴퓨터 자원이 많이 소모 된다. 서버 트래픽에 따라 비용이 만만치 않을 수도 있게 된다.
- 클라이언트와 서버간의 안전한 통신을 위해 채널을 수립하는 Handshake 과정에서 공개키를 사용한다.
- 실제 데이터를 주고 받는 과정에서는 대칭키 방식을 이용한다.

### 동작 과정

SSL 동작은 크게 세 단계로 이루어 진다.

> 1. **Handshake** (서로 소통 할 채널을 수립하는 과정)
>   - 프로토콜 버전 번호 교환
>   - 양쪽이 알고 있는 암호화 방식 선택
>   - 서로의 신원을 인증
>   - 채널을 암호화 하기 위한 임시 세션 키 생성
> 2. **데이터 전송**
> 3. **세션 종료**

좀 더 과정을 상세히 들여다 보자면,

1. **클라이언트에서 서버로 데이터 전송**
    - 클라이언트는 랜덤 데이터를 생성하여 전달한다.
    - 사용 가능한 암호화 방식의 후보들
    <br />
2. **서버에서 클라이언트로 데이터 전송**
    - 서버가 생성한 랜덤 데이터를 전달한다
    - 서버가 선택한 클라이언트의 암호화 방식
    - 인증서 (CA로 부터 발급)
   	<br />
3. **클라이언트는 인증서를 검증한다.**
    - 인증서가 CA에 의해서 발급 된 것인지
    - 서로 주고 받은 랜덤 데이터를 조합해서, **`pre master secret key`** (이후에 대칭키로 사용된다)를 생성,인증서에 담겨있는 공개 키를 통해 암호화 하여 전송
        <br />
4. **서버는 pre master secret key를 복호화**
    - 서버가 가지고 있는 비밀키를 통해 **`pre master secret key`**를 복호화 한다.
    - 이로써 클라이언트 - 서버 둘 다 **`pre master secret key`**를 공유하게 된다.
        <br />
5. **서버와 클라이언트 모두  일련의 과정을 거쳐 pre master secret key를 master secret 값으로 생성**
    - **`master secret`**를 통해 **`session key`**를 생성
    - 클라이언트 - 서버 둘 다 동일한 **`session key`**를 가지게 된다
    - 서버-클라이언트 모두 **`session key`**를 통해 주고 받는 데이터를 암호화 하여 주고 받을 수 있게 된다. (대칭키 방식)
        <br />
6. **세션**
    - 실제로 서버와 클라이언트가 데이터를 주고 받는 단계
    - **`session key`** 값을 이용하여 데이터를 암호화 하여 주고 받는다. (대칭키 방식)
        <br />
7. **세션 종료**
    - 데이터 전송이 끝나면 서로에게 SSL 통신이 끝났음을 알린다 .
    - 통신에서 사용한 대칭키인 **`session key를 폐기`**한다.

<br />

세션의 수립과 세션의 종료는 순식간의 이루어지기 때문에 중간에 대칭키가 유출되더라도, 이미 폐지되어 안전하다고 한다.
물론 100% 안전을 장담 할 수는 없을 것이다.

<br />

---

**참고 자료**

> [생활코딩 HTTPS / SSL](https://opentutorials.org/course/228/4894#signiture)
